<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "8cbf460468c802c7994aa62e0e0779c9",
  "translation_date": "2025-07-12T12:12:47+00:00",
  "source_file": "09-metacognition/README.md",
  "language_code": "hi"
}
-->
[![Multi-Agent Design](../../../translated_images/lesson-9-thumbnail.38059e8af1a5b71d890c92f576f933c6a307c691339dca7e8ca6ea75a8d857a1.hi.png)](https://youtu.be/His9R6gw6Ec?si=3_RMb8VprNvdLRhX)

> _(इस पाठ का वीडियो देखने के लिए ऊपर की छवि पर क्लिक करें)_
# AI एजेंट्स में मेटाकॉग्निशन

## परिचय

AI एजेंट्स में मेटाकॉग्निशन पर इस पाठ में आपका स्वागत है! यह अध्याय उन शुरुआती लोगों के लिए बनाया गया है जो जानना चाहते हैं कि AI एजेंट्स अपने सोचने की प्रक्रियाओं के बारे में कैसे सोच सकते हैं। इस पाठ के अंत तक, आप मुख्य अवधारणाओं को समझ जाएंगे और मेटाकॉग्निशन को AI एजेंट डिजाइन में लागू करने के लिए व्यावहारिक उदाहरणों से लैस होंगे।

## सीखने के लक्ष्य

इस पाठ को पूरा करने के बाद, आप सक्षम होंगे:

1. एजेंट परिभाषाओं में तर्क चक्रों के प्रभाव को समझना।
2. स्व-सुधार करने वाले एजेंट्स की मदद के लिए योजना और मूल्यांकन तकनीकों का उपयोग करना।
3. अपने स्वयं के ऐसे एजेंट बनाना जो कार्यों को पूरा करने के लिए कोड को संशोधित कर सकें।

## मेटाकॉग्निशन का परिचय

मेटाकॉग्निशन का मतलब है उच्च स्तरीय संज्ञानात्मक प्रक्रियाएं जो अपनी सोच के बारे में सोचने से जुड़ी होती हैं। AI एजेंट्स के लिए, इसका अर्थ है कि वे अपनी क्रियाओं का मूल्यांकन कर सकें और आत्म-जागरूकता और पिछले अनुभवों के आधार पर उन्हें समायोजित कर सकें। मेटाकॉग्निशन, या "सोच के बारे में सोचना," एजेंटिक AI सिस्टम के विकास में एक महत्वपूर्ण अवधारणा है। इसमें AI सिस्टम अपने आंतरिक प्रक्रियाओं के प्रति जागरूक होते हैं और अपने व्यवहार की निगरानी, नियंत्रण और अनुकूलन कर सकते हैं। ठीक वैसे ही जैसे हम किसी स्थिति को समझते हैं या किसी समस्या को देखते हैं। यह आत्म-जागरूकता AI सिस्टम को बेहतर निर्णय लेने, त्रुटियों की पहचान करने और समय के साथ प्रदर्शन सुधारने में मदद कर सकती है—जो ट्यूरिंग टेस्ट और AI के नियंत्रण लेने की बहस से भी जुड़ती है।

एजेंटिक AI सिस्टम के संदर्भ में, मेटाकॉग्निशन कई चुनौतियों को हल करने में मदद कर सकता है, जैसे:
- पारदर्शिता: यह सुनिश्चित करना कि AI सिस्टम अपने तर्क और निर्णय समझा सकें।
- तर्क: AI सिस्टम की जानकारी को संयोजित करने और सही निर्णय लेने की क्षमता को बढ़ाना।
- अनुकूलन: AI सिस्टम को नए वातावरण और बदलती परिस्थितियों के अनुसार समायोजित करने देना।
- धारणा: AI सिस्टम की अपने पर्यावरण से डेटा पहचानने और व्याख्या करने की सटीकता में सुधार।

### मेटाकॉग्निशन क्या है?

मेटाकॉग्निशन, या "सोच के बारे में सोचना," एक उच्च स्तरीय संज्ञानात्मक प्रक्रिया है जिसमें अपनी संज्ञानात्मक प्रक्रियाओं की आत्म-जागरूकता और आत्म-नियमन शामिल होता है। AI के क्षेत्र में, मेटाकॉग्निशन एजेंट्स को अपनी रणनीतियों और क्रियाओं का मूल्यांकन और अनुकूलन करने में सक्षम बनाता है, जिससे समस्या समाधान और निर्णय लेने की क्षमताओं में सुधार होता है। मेटाकॉग्निशन को समझकर, आप ऐसे AI एजेंट डिजाइन कर सकते हैं जो न केवल अधिक बुद्धिमान बल्कि अधिक अनुकूलनीय और कुशल भी हों। सच्चे मेटाकॉग्निशन में, आप AI को स्पष्ट रूप से अपने तर्क के बारे में तर्क करते हुए देखेंगे।

उदाहरण: "मैंने सस्ते फ्लाइट्स को प्राथमिकता दी क्योंकि... हो सकता है कि मैं डायरेक्ट फ्लाइट्स से चूक रहा हूँ, इसलिए मैं फिर से जांच करता हूँ।"
यह ट्रैक रखना कि उसने किसी विशेष मार्ग को क्यों चुना।
- यह नोट करना कि उसने गलती की क्योंकि उसने पिछली बार उपयोगकर्ता की प्राथमिकताओं पर अधिक निर्भर किया, इसलिए वह अपनी निर्णय लेने की रणनीति को बदलता है, न कि केवल अंतिम सिफारिश को।
- पैटर्न का निदान करना जैसे, "जब भी मैं उपयोगकर्ता को 'बहुत भीड़' कहते देखता हूँ, तो मुझे न केवल कुछ आकर्षण हटाने चाहिए बल्कि यह भी सोचना चाहिए कि मेरी 'शीर्ष आकर्षण' चुनने की विधि दोषपूर्ण है यदि मैं हमेशा लोकप्रियता के आधार पर रैंक करता हूँ।"

### AI एजेंट्स में मेटाकॉग्निशन का महत्व

मेटाकॉग्निशन AI एजेंट डिजाइन में कई कारणों से महत्वपूर्ण भूमिका निभाता है:

![Importance of Metacognition](../../../translated_images/importance-of-metacognition.b381afe9aae352f7734c8628ea3f4b23084634b791c5a120c76a02bb7eeeb7ec.hi.png)

- आत्म-प्रतिबिंब: एजेंट अपने प्रदर्शन का आकलन कर सकते हैं और सुधार के क्षेत्र पहचान सकते हैं।
- अनुकूलनशीलता: एजेंट अपने रणनीतियों को पिछले अनुभवों और बदलते वातावरण के आधार पर संशोधित कर सकते हैं।
- त्रुटि सुधार: एजेंट स्वायत्त रूप से त्रुटियों का पता लगा सकते हैं और उन्हें सुधार सकते हैं, जिससे परिणाम अधिक सटीक होते हैं।
- संसाधन प्रबंधन: एजेंट अपनी क्रियाओं की योजना और मूल्यांकन करके समय और कम्प्यूटेशनल शक्ति जैसे संसाधनों का बेहतर उपयोग कर सकते हैं।

## AI एजेंट के घटक

मेटाकॉग्निटिव प्रक्रियाओं में जाने से पहले, AI एजेंट के मूल घटकों को समझना आवश्यक है। एक AI एजेंट आमतौर पर निम्नलिखित से बना होता है:

- पर्सोना: एजेंट की व्यक्तित्व और विशेषताएं, जो यह परिभाषित करती हैं कि वह उपयोगकर्ताओं के साथ कैसे इंटरैक्ट करता है।
- टूल्स: वे क्षमताएं और कार्य जो एजेंट कर सकता है।
- स्किल्स: वह ज्ञान और विशेषज्ञता जो एजेंट के पास होती है।

ये घटक मिलकर एक "विशेषज्ञता इकाई" बनाते हैं जो विशिष्ट कार्य कर सकती है।

**उदाहरण**:
एक ट्रैवल एजेंट को सोचें, जो न केवल आपकी छुट्टियों की योजना बनाता है बल्कि वास्तविक समय के डेटा और पिछले ग्राहक यात्रा अनुभवों के आधार पर अपनी योजना को समायोजित भी करता है।

### उदाहरण: ट्रैवल एजेंट सेवा में मेटाकॉग्निशन

कल्पना करें कि आप AI संचालित ट्रैवल एजेंट सेवा डिजाइन कर रहे हैं। यह एजेंट, "Travel Agent," उपयोगकर्ताओं की छुट्टियों की योजना बनाने में मदद करता है। मेटाकॉग्निशन को शामिल करने के लिए, Travel Agent को अपनी क्रियाओं का मूल्यांकन और समायोजन करना होगा, जो आत्म-जागरूकता और पिछले अनुभवों पर आधारित हो। मेटाकॉग्निशन इस प्रकार काम कर सकता है:

#### वर्तमान कार्य

वर्तमान कार्य उपयोगकर्ता की पेरिस यात्रा की योजना बनाना है।

#### कार्य पूरा करने के चरण

1. **उपयोगकर्ता की प्राथमिकताएं इकट्ठा करें**: उपयोगकर्ता से उनके यात्रा की तारीखें, बजट, रुचियां (जैसे संग्रहालय, भोजन, खरीदारी) और कोई विशेष आवश्यकताएं पूछें।
2. **जानकारी प्राप्त करें**: उड़ान विकल्प, आवास, आकर्षण और रेस्तरां खोजें जो उपयोगकर्ता की प्राथमिकताओं से मेल खाते हों।
3. **सिफारिशें बनाएं**: उड़ान विवरण, होटल आरक्षण और सुझाए गए गतिविधियों के साथ एक व्यक्तिगत यात्रा कार्यक्रम प्रदान करें।
4. **प्रतिक्रिया के आधार पर समायोजन करें**: सिफारिशों पर उपयोगकर्ता से प्रतिक्रिया लें और आवश्यक समायोजन करें।

#### आवश्यक संसाधन

- उड़ान और होटल बुकिंग डेटाबेस तक पहुंच।
- पेरिस के आकर्षण और रेस्तरां की जानकारी।
- पिछले इंटरैक्शन से उपयोगकर्ता प्रतिक्रिया डेटा।

#### अनुभव और आत्म-प्रतिबिंब

Travel Agent मेटाकॉग्निशन का उपयोग करके अपने प्रदर्शन का मूल्यांकन करता है और पिछले अनुभवों से सीखता है। उदाहरण के लिए:

1. **उपयोगकर्ता प्रतिक्रिया का विश्लेषण**: Travel Agent उपयोगकर्ता की प्रतिक्रिया की समीक्षा करता है ताकि यह पता चले कि कौन सी सिफारिशें अच्छी लगीं और कौन सी नहीं। वह भविष्य की सिफारिशों को उसी अनुसार समायोजित करता है।
2. **अनुकूलनशीलता**: यदि किसी उपयोगकर्ता ने पहले भीड़-भाड़ वाले स्थानों को नापसंद किया है, तो Travel Agent भविष्य में पीक आवर्स में लोकप्रिय पर्यटन स्थलों की सिफारिश से बचेगा।
3. **त्रुटि सुधार**: यदि Travel Agent ने पिछली बुकिंग में कोई गलती की, जैसे कि एक होटल जो पूरी तरह बुक था, तो वह भविष्य में उपलब्धता की जांच अधिक सख्ती से करेगा।

#### व्यावहारिक डेवलपर उदाहरण

यहाँ एक सरल उदाहरण है कि Travel Agent का कोड मेटाकॉग्निशन को शामिल करते हुए कैसा दिख सकता है:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        # Search for flights, hotels, and attractions based on preferences
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        # Analyze feedback and adjust future recommendations
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

#### मेटाकॉग्निशन क्यों महत्वपूर्ण है

- **आत्म-प्रतिबिंब**: एजेंट अपने प्रदर्शन का विश्लेषण कर सुधार के क्षेत्र पहचान सकते हैं।
- **अनुकूलनशीलता**: एजेंट प्रतिक्रिया और बदलती परिस्थितियों के आधार पर रणनीतियों को संशोधित कर सकते हैं।
- **त्रुटि सुधार**: एजेंट स्वायत्त रूप से गलतियों का पता लगा कर उन्हें सुधार सकते हैं।
- **संसाधन प्रबंधन**: एजेंट समय और कम्प्यूटेशनल शक्ति जैसे संसाधनों का बेहतर उपयोग कर सकते हैं।

मेटाकॉग्निशन को शामिल करके, Travel Agent अधिक व्यक्तिगत और सटीक यात्रा सिफारिशें प्रदान कर सकता है, जिससे उपयोगकर्ता का अनुभव बेहतर होता है।

---

## 2. एजेंट्स में योजना बनाना

योजना बनाना AI एजेंट के व्यवहार का एक महत्वपूर्ण हिस्सा है। इसमें लक्ष्य प्राप्ति के लिए आवश्यक कदमों को निर्धारित करना शामिल है, जिसमें वर्तमान स्थिति, संसाधन और संभावित बाधाओं को ध्यान में रखा जाता है।

### योजना के तत्व

- **वर्तमान कार्य**: कार्य को स्पष्ट रूप से परिभाषित करें।
- **कार्य पूरा करने के चरण**: कार्य को प्रबंधनीय चरणों में विभाजित करें।
- **आवश्यक संसाधन**: आवश्यक संसाधनों की पहचान करें।
- **अनुभव**: योजना बनाने में पिछले अनुभवों का उपयोग करें।

**उदाहरण**:
यहाँ वे चरण हैं जो Travel Agent को उपयोगकर्ता की यात्रा की योजना बनाने में मदद करने के लिए लेने होंगे:

### Travel Agent के लिए चरण

1. **उपयोगकर्ता की प्राथमिकताएं इकट्ठा करें**
   - उपयोगकर्ता से उनकी यात्रा की तारीखें, बजट, रुचियां और कोई विशेष आवश्यकताएं पूछें।
   - उदाहरण: "आप कब यात्रा करने की योजना बना रहे हैं?" "आपका बजट कितना है?" "आप छुट्टियों में कौन-कौन सी गतिविधियां पसंद करते हैं?"

2. **जानकारी प्राप्त करें**
   - उपयोगकर्ता की प्राथमिकताओं के आधार पर संबंधित यात्रा विकल्प खोजें।
   - **उड़ानें**: उपयोगकर्ता के बजट और पसंदीदा यात्रा तिथियों के भीतर उपलब्ध उड़ानें देखें।
   - **आवास**: ऐसे होटल या किराये की जगहें खोजें जो स्थान, कीमत और सुविधाओं के हिसाब से उपयुक्त हों।
   - **आकर्षण और रेस्तरां**: लोकप्रिय आकर्षण, गतिविधियां और भोजन विकल्प पहचानें जो उपयोगकर्ता की रुचियों से मेल खाते हों।

3. **सिफारिशें बनाएं**
   - प्राप्त जानकारी को एक व्यक्तिगत यात्रा कार्यक्रम में संकलित करें।
   - उड़ान विकल्प, होटल आरक्षण और सुझाई गई गतिविधियों का विवरण प्रदान करें, सुनिश्चित करें कि सिफारिशें उपयोगकर्ता की प्राथमिकताओं के अनुसार हों।

4. **यात्रा कार्यक्रम उपयोगकर्ता को प्रस्तुत करें**
   - प्रस्तावित यात्रा कार्यक्रम को उपयोगकर्ता के समीक्षा के लिए साझा करें।
   - उदाहरण: "यहाँ आपकी पेरिस यात्रा के लिए सुझाया गया यात्रा कार्यक्रम है। इसमें उड़ान विवरण, होटल बुकिंग और सुझाई गई गतिविधियां और रेस्तरां शामिल हैं। कृपया अपनी राय दें!"

5. **प्रतिक्रिया एकत्र करें**
   - प्रस्तावित यात्रा कार्यक्रम पर उपयोगकर्ता से प्रतिक्रिया मांगें।
   - उदाहरण: "क्या आपको उड़ान विकल्प पसंद आए?" "क्या होटल आपकी आवश्यकताओं के अनुसार है?" "क्या आप कोई गतिविधि जोड़ना या हटाना चाहेंगे?"

6. **प्रतिक्रिया के आधार पर समायोजन करें**
   - उपयोगकर्ता की प्रतिक्रिया के अनुसार यात्रा कार्यक्रम में आवश्यक बदलाव करें।
   - उड़ान, आवास और गतिविधि सिफारिशों को बेहतर बनाने के लिए आवश्यक परिवर्तन करें।

7. **अंतिम पुष्टि**
   - अंतिम पुष्टि के लिए अपडेट किया गया यात्रा कार्यक्रम उपयोगकर्ता को प्रस्तुत करें।
   - उदाहरण: "मैंने आपकी प्रतिक्रिया के आधार पर बदलाव किए हैं। यह अपडेटेड यात्रा कार्यक्रम है। क्या सब कुछ ठीक लग रहा है?"

8. **बुकिंग और पुष्टि करें**
   - उपयोगकर्ता की मंजूरी मिलने के बाद, उड़ानें, आवास और पूर्व-निर्धारित गतिविधियों की बुकिंग करें।
   - पुष्टि विवरण उपयोगकर्ता को भेजें।

9. **लगातार सहायता प्रदान करें**
   - यात्रा के दौरान और पहले किसी भी बदलाव या अतिरिक्त अनुरोध में उपयोगकर्ता की मदद के लिए उपलब्ध रहें।
   - उदाहरण: "यदि आपकी यात्रा के दौरान आपको किसी भी सहायता की आवश्यकता हो, तो मुझसे कभी भी संपर्क करें!"

### उदाहरण इंटरैक्शन

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        itinerary = create_itinerary(flights, hotels, attractions)
        return itinerary

    def adjust_based_on_feedback(self, feedback):
        self.experience_data.append(feedback)
        self.user_preferences = adjust_preferences(self.user_preferences, feedback)

# Example usage within a booing request
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
travel_agent.adjust_based_on_feedback(feedback)
```

## 3. सुधारात्मक RAG सिस्टम

सबसे पहले, RAG टूल और प्री-एम्प्टिव कॉन्टेक्स्ट लोड के बीच अंतर को समझते हैं।

![RAG vs Context Loading](../../../translated_images/rag-vs-context.9eae588520c00921f531e4dc788992e8a7b69b6ff7c9eaa69fb9bc83ad243504.hi.png)

### Retrieval-Augmented Generation (RAG)

RAG एक पुनःप्राप्ति प्रणाली को एक जनरेटिव मॉडल के साथ जोड़ता है। जब कोई क्वेरी की जाती है, तो पुनःप्राप्ति प्रणाली बाहरी स्रोत से संबंधित दस्तावेज़ या डेटा लाती है, और इस प्राप्त जानकारी का उपयोग जनरेटिव मॉडल के इनपुट को बढ़ाने के लिए किया जाता है। इससे मॉडल अधिक सटीक और संदर्भानुकूल प्रतिक्रियाएं उत्पन्न कर पाता है।

RAG सिस्टम में, एजेंट ज्ञान आधार से प्रासंगिक जानकारी प्राप्त करता है और इसका उपयोग उपयुक्त प्रतिक्रियाएं या क्रियाएं उत्पन्न करने के लिए करता है।

### सुधारात्मक RAG दृष्टिकोण

सुधारात्मक RAG दृष्टिकोण RAG तकनीकों का उपयोग करके AI एजेंट्स की त्रुटियों को सुधारने और उनकी सटीकता बढ़ाने पर केंद्रित है। इसमें शामिल हैं:

1. **प्रॉम्प्टिंग तकनीक**: एजेंट को प्रासंगिक जानकारी प्राप्त करने के लिए विशिष्ट प्रॉम्प्ट्स का उपयोग करना।
2. **टूल**: ऐसे एल्गोरिदम और तंत्र लागू करना जो एजेंट को प्राप्त जानकारी की प्रासंगिकता का मूल्यांकन करने और सटीक प्रतिक्रियाएं उत्पन्न करने में सक्षम बनाएं।
3. **मूल्यांकन**: एजेंट के प्रदर्शन का निरंतर आकलन करना और उसकी सटीकता और दक्षता सुधारने के लिए समायोजन करना।

#### उदाहरण: एक सर्च एजेंट में सुधारात्मक RAG

एक सर्च एजेंट को सोचें जो वेब से जानकारी प्राप्त करता है ताकि उपयोगकर्ता के प्रश्नों का उत्तर दे सके। सुधारात्मक RAG दृष्टिकोण में शामिल हो सकता है:

1. **प्रॉम्प्टिंग तकनीक**: उपयोगकर्ता के इनपुट के आधार पर खोज क्वेरी बनाना।
2. **टूल**: प्राकृतिक भाषा प्रसंस्करण और मशीन लर्निंग एल्गोरिदम का उपयोग करके खोज परिणामों को रैंक और फ़िल्टर करना।
3. **मूल्यांकन**: उपयोगकर्ता की प्रतिक्रिया का विश्लेषण करके प्राप्त जानकारी में त्रुटियों की पहचान और सुधार करना।

### ट्रैवल एजेंट में सुधारात्मक RAG

सुधारात्मक RAG (Retrieval-Augmented Generation) AI की जानकारी प्राप्त करने और उत्पन्न करने की क्षमता को बढ़ाता है, साथ ही किसी भी त्रुटि को सुधारता है। आइए देखें कि ट्रैवल एजेंट कैसे सुधारात्मक RAG दृष्टिकोण का उपयोग करके अधिक सटीक और प्रासंगिक यात्रा सिफारिशें प्रदान कर सकता है।

इसमें शामिल हैं:

- **प्रॉम्प्टिंग तकनीक:** एजेंट को प्रासंगिक जानकारी प्राप्त करने के लिए विशिष्ट प्रॉम्प्ट्स का उपयोग करना।
- **टूल:** ऐसे एल्गोरिदम और तंत्र लागू करना जो एजेंट को प्राप्त जानकारी की प्रासंगिकता का मूल्यांकन करने और सटीक प्रतिक्रियाएं उत्पन्न करने में सक्षम बनाएं।
- **मूल्यांकन:** एजेंट के प्रदर्शन का निरंतर आकलन करना और उसकी सटीकता और दक्षता सुधारने के लिए समायोजन करना।

#### ट्रैवल एजेंट में सुधारात्मक RAG लागू करने के चरण

1. **प्रारंभिक उपयोगकर्ता इंटरैक्शन**
   - ट्रैवल एजेंट उपयोगकर्ता से प्रारंभिक प्राथमिकताएं इकट्ठा करता है, जैसे गंतव्य, यात्रा तिथियां, बजट और रुचियां।
   - उदाहरण:

     ```python
     preferences = {
         "destination": "Paris",
         "dates": "2025-04-01 to 2025-04-10",
         "budget": "moderate",
         "interests": ["museums", "cuisine"]
     }
     ```

2. **जानकारी प्राप्त करना**
   - ट्रैवल एजेंट उपयोगकर्ता की प्राथमिकताओं के आधार पर उड़ान, आवास, आकर्षण और रेस्तरां की जानकारी प्राप्त करता है।
   - उदाहरण:

     ```python
     flights = search_flights(preferences)
     hotels = search_hotels(preferences)
     attractions = search_attractions(preferences)
     ```

3. **प्रारंभिक सिफारिशें बनाना**
   - ट्रैवल एजेंट प्राप्त जानकारी का उपयोग करके एक व्यक्तिगत यात्रा कार्यक्रम बनाता है।
   - उदाहरण:

     ```python
     itinerary = create_itinerary(flights, hotels, attractions)
     print("Suggested Itinerary:", itinerary)
     ```

4. **उपयोगकर्ता प्रतिक्रिया एकत्र करना**
   - ट्रैवल एजेंट प्रारंभिक सिफारिशों पर उपयोगकर्ता से प्रतिक्रिया मांगता है।
   - उदाहरण:

     ```python
     feedback = {
         "liked": ["Louvre Museum"],
         "disliked": ["Eiffel Tower (too crowded)"]
     }
     ```

5. **सुधारात्मक RAG प्रक्रिया**
   - **प्रॉम्प्टिंग तकनीक**: ट्रैवल एजेंट उपयोगकर्ता की प्रतिक्रिया के आधार पर नई खोज क्वेरी बनाता है।
     - उदाहरण:

       ```python
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       ```

   - **टूल**: ट्रैवल एजेंट नए खोज परिणामों को रैंक और फ़िल्टर करने के लिए एल्गोरिदम का उपयोग करता है, उपयोगकर्ता की प्रतिक्रिया के आधार पर प्रासंगिकता पर जोर देता है।
     - उदाहरण:

       ```python
       new_attractions = search_attractions(preferences)
       new_itinerary = create_itinerary(flights, hotels, new_attractions)
       print("Updated Itinerary:", new_itinerary)
       ```

   - **मूल्यांकन**: ट्रैवल एजेंट उपयोगकर्ता की प्रतिक्रिया का विश्लेषण करके अपनी सिफारिशों की प्र
### पूर्व-संदर्भ लोड

पूर्व-संदर्भ लोड का मतलब है कि किसी क्वेरी को प्रोसेस करने से पहले मॉडल में संबंधित संदर्भ या पृष्ठभूमि की जानकारी लोड कर देना। इसका मतलब है कि मॉडल को शुरुआत से ही यह जानकारी उपलब्ध होती है, जिससे वह अतिरिक्त डेटा खोजे बिना अधिक सूचित उत्तर दे सकता है।

यहाँ एक सरल उदाहरण है कि कैसे एक ट्रैवल एजेंट एप्लिकेशन में पूर्व-संदर्भ लोड दिख सकता है, Python में:

```python
class TravelAgent:
    def __init__(self):
        # Pre-load popular destinations and their information
        self.context = {
            "Paris": {"country": "France", "currency": "Euro", "language": "French", "attractions": ["Eiffel Tower", "Louvre Museum"]},
            "Tokyo": {"country": "Japan", "currency": "Yen", "language": "Japanese", "attractions": ["Tokyo Tower", "Shibuya Crossing"]},
            "New York": {"country": "USA", "currency": "Dollar", "language": "English", "attractions": ["Statue of Liberty", "Times Square"]},
            "Sydney": {"country": "Australia", "currency": "Dollar", "language": "English", "attractions": ["Sydney Opera House", "Bondi Beach"]}
        }

    def get_destination_info(self, destination):
        # Fetch destination information from pre-loaded context
        info = self.context.get(destination)
        if info:
            return f"{destination}:\nCountry: {info['country']}\nCurrency: {info['currency']}\nLanguage: {info['language']}\nAttractions: {', '.join(info['attractions'])}"
        else:
            return f"Sorry, we don't have information on {destination}."

# Example usage
travel_agent = TravelAgent()
print(travel_agent.get_destination_info("Paris"))
print(travel_agent.get_destination_info("Tokyo"))
```

#### व्याख्या

1. **इनिशियलाइज़ेशन (`__init__` मेथड)**: `TravelAgent` क्लास लोकप्रिय गंतव्यों जैसे पेरिस, टोक्यो, न्यूयॉर्क, और सिडनी की जानकारी वाला एक डिक्शनरी पहले से लोड करता है। इस डिक्शनरी में प्रत्येक गंतव्य के देश, मुद्रा, भाषा, और प्रमुख आकर्षण शामिल होते हैं।

2. **जानकारी प्राप्त करना (`get_destination_info` मेथड)**: जब उपयोगकर्ता किसी विशेष गंतव्य के बारे में पूछता है, तो `get_destination_info` मेथड पूर्व-लोड किए गए संदर्भ डिक्शनरी से संबंधित जानकारी प्राप्त करता है।

पूर्व-संदर्भ लोड करके, ट्रैवल एजेंट एप्लिकेशन उपयोगकर्ता के प्रश्नों का तुरंत जवाब दे सकता है बिना वास्तविक समय में बाहरी स्रोत से जानकारी खोजे। इससे एप्लिकेशन अधिक कुशल और प्रतिक्रियाशील बनता है।

### लक्ष्य के साथ योजना की शुरुआत करना और फिर पुनरावृत्ति करना

लक्ष्य के साथ योजना की शुरुआत करने का मतलब है कि शुरुआत में ही एक स्पष्ट उद्देश्य या लक्ष्य निर्धारित करना। इस लक्ष्य को पहले से परिभाषित करके, मॉडल इसे मार्गदर्शक सिद्धांत के रूप में उपयोग कर सकता है। इससे हर पुनरावृत्ति लक्ष्य की ओर बढ़ती है, जिससे प्रक्रिया अधिक प्रभावी और केंद्रित होती है।

यहाँ एक उदाहरण है कि कैसे आप Python में ट्रैवल एजेंट के लिए लक्ष्य के साथ यात्रा योजना की शुरुआत कर सकते हैं और फिर उसे पुनरावृत्त कर सकते हैं:

### परिदृश्य

एक ट्रैवल एजेंट ग्राहक के लिए एक कस्टमाइज्ड छुट्टियों की योजना बनाना चाहता है। लक्ष्य है ग्राहक की पसंद और बजट के आधार पर उनकी संतुष्टि को अधिकतम करने वाली यात्रा योजना बनाना।

### चरण

1. ग्राहक की पसंद और बजट निर्धारित करें।
2. इन पसंदों के आधार पर प्रारंभिक योजना बनाएं।
3. योजना को पुनरावृत्त करके ग्राहक की संतुष्टि के लिए अनुकूलित करें।

#### Python कोड

```python
class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def bootstrap_plan(self, preferences, budget):
        plan = []
        total_cost = 0

        for destination in self.destinations:
            if total_cost + destination['cost'] <= budget and self.match_preferences(destination, preferences):
                plan.append(destination)
                total_cost += destination['cost']

        return plan

    def match_preferences(self, destination, preferences):
        for key, value in preferences.items():
            if destination.get(key) != value:
                return False
        return True

    def iterate_plan(self, plan, preferences, budget):
        for i in range(len(plan)):
            for destination in self.destinations:
                if destination not in plan and self.match_preferences(destination, preferences) and self.calculate_cost(plan, destination) <= budget:
                    plan[i] = destination
                    break
        return plan

    def calculate_cost(self, plan, new_destination):
        return sum(destination['cost'] for destination in plan) + new_destination['cost']

# Example usage
destinations = [
    {"name": "Paris", "cost": 1000, "activity": "sightseeing"},
    {"name": "Tokyo", "cost": 1200, "activity": "shopping"},
    {"name": "New York", "cost": 900, "activity": "sightseeing"},
    {"name": "Sydney", "cost": 1100, "activity": "beach"},
]

preferences = {"activity": "sightseeing"}
budget = 2000

travel_agent = TravelAgent(destinations)
initial_plan = travel_agent.bootstrap_plan(preferences, budget)
print("Initial Plan:", initial_plan)

refined_plan = travel_agent.iterate_plan(initial_plan, preferences, budget)
print("Refined Plan:", refined_plan)
```

#### कोड व्याख्या

1. **इनिशियलाइज़ेशन (`__init__` मेथड)**: `TravelAgent` क्लास संभावित गंतव्यों की एक सूची के साथ इनिशियलाइज़ होती है, जिनमें नाम, लागत, और गतिविधि प्रकार जैसे गुण होते हैं।

2. **योजना की शुरुआत (`bootstrap_plan` मेथड)**: यह मेथड ग्राहक की पसंद और बजट के आधार पर प्रारंभिक यात्रा योजना बनाता है। यह गंतव्यों की सूची में से उन गंतव्यों को योजना में जोड़ता है जो ग्राहक की पसंद से मेल खाते हैं और बजट में फिट होते हैं।

3. **पसंद मिलान (`match_preferences` मेथड)**: यह मेथड जांचता है कि कोई गंतव्य ग्राहक की पसंद से मेल खाता है या नहीं।

4. **योजना पुनरावृत्ति (`iterate_plan` मेथड)**: यह मेथड प्रारंभिक योजना को बेहतर बनाने के लिए प्रत्येक गंतव्य को ग्राहक की पसंद और बजट को ध्यान में रखते हुए बेहतर विकल्प से बदलने की कोशिश करता है।

5. **लागत गणना (`calculate_cost` मेथड)**: यह मेथड वर्तमान योजना की कुल लागत की गणना करता है, जिसमें संभावित नया गंतव्य भी शामिल हो सकता है।

#### उदाहरण उपयोग

- **प्रारंभिक योजना**: ट्रैवल एजेंट ग्राहक की सैर-सपाटा पसंद और $2000 के बजट के आधार पर प्रारंभिक योजना बनाता है।
- **सुधारित योजना**: ट्रैवल एजेंट योजना को पुनरावृत्त करता है, ग्राहक की पसंद और बजट के अनुसार अनुकूलित करता है।

लक्ष्य (जैसे ग्राहक की संतुष्टि को अधिकतम करना) के साथ योजना की शुरुआत करके और पुनरावृत्ति के माध्यम से योजना को परिष्कृत करके, ट्रैवल एजेंट ग्राहक के लिए एक कस्टमाइज्ड और अनुकूलित यात्रा कार्यक्रम बना सकता है। यह तरीका सुनिश्चित करता है कि यात्रा योजना शुरुआत से ही ग्राहक की पसंद और बजट के अनुरूप हो और हर पुनरावृत्ति के साथ बेहतर होती जाए।

### LLM का पुनः रैंकिंग और स्कोरिंग के लिए उपयोग

बड़े भाषा मॉडल (LLMs) का उपयोग पुनः रैंकिंग और स्कोरिंग के लिए किया जा सकता है, जो प्राप्त दस्तावेज़ों या उत्पन्न उत्तरों की प्रासंगिकता और गुणवत्ता का मूल्यांकन करते हैं। यह प्रक्रिया इस प्रकार काम करती है:

**प्राप्ति:** प्रारंभिक प्राप्ति चरण में क्वेरी के आधार पर संभावित दस्तावेज़ या उत्तरों का सेट लाया जाता है।

**पुनः रैंकिंग:** LLM इन उम्मीदवारों का मूल्यांकन करता है और उनकी प्रासंगिकता और गुणवत्ता के आधार पर उन्हें पुनः रैंक करता है। इससे सबसे प्रासंगिक और उच्च गुणवत्ता वाली जानकारी पहले प्रस्तुत होती है।

**स्कोरिंग:** LLM प्रत्येक उम्मीदवार को प्रासंगिकता और गुणवत्ता के अनुसार स्कोर देता है, जिससे सबसे अच्छा उत्तर या दस्तावेज़ चुना जा सके।

LLM का उपयोग पुनः रैंकिंग और स्कोरिंग के लिए करके, सिस्टम अधिक सटीक और संदर्भानुकूल जानकारी प्रदान कर सकता है, जिससे उपयोगकर्ता का अनुभव बेहतर होता है।

यहाँ एक उदाहरण है कि कैसे एक ट्रैवल एजेंट उपयोगकर्ता की पसंद के आधार पर यात्रा गंतव्यों को पुनः रैंक और स्कोर करने के लिए Azure OpenAI सेवा का उपयोग कर सकता है, Python में:

#### परिदृश्य - पसंद के आधार पर यात्रा

एक ट्रैवल एजेंट ग्राहक की पसंद के आधार पर सर्वोत्तम यात्रा गंतव्य सुझाना चाहता है। LLM गंतव्यों को पुनः रैंक और स्कोर करने में मदद करेगा ताकि सबसे प्रासंगिक विकल्प प्रस्तुत किए जा सकें।

#### चरण:

1. उपयोगकर्ता की पसंद एकत्र करें।
2. संभावित यात्रा गंतव्यों की सूची प्राप्त करें।
3. उपयोगकर्ता की पसंद के आधार पर गंतव्यों को पुनः रैंक और स्कोर करने के लिए LLM का उपयोग करें।

पिछले उदाहरण को Azure OpenAI सेवाओं के साथ अपडेट करने का तरीका इस प्रकार है:

#### आवश्यकताएँ

1. आपके पास Azure सब्सक्रिप्शन होना चाहिए।
2. Azure OpenAI संसाधन बनाएं और अपनी API कुंजी प्राप्त करें।

#### उदाहरण Python कोड

```python
import requests
import json

class TravelAgent:
    def __init__(self, destinations):
        self.destinations = destinations

    def get_recommendations(self, preferences, api_key, endpoint):
        # Generate a prompt for the Azure OpenAI
        prompt = self.generate_prompt(preferences)
        
        # Define headers and payload for the request
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "prompt": prompt,
            "max_tokens": 150,
            "temperature": 0.7
        }
        
        # Call the Azure OpenAI API to get the re-ranked and scored destinations
        response = requests.post(endpoint, headers=headers, json=payload)
        response_data = response.json()
        
        # Extract and return the recommendations
        recommendations = response_data['choices'][0]['text'].strip().split('\n')
        return recommendations

    def generate_prompt(self, preferences):
        prompt = "Here are the travel destinations ranked and scored based on the following user preferences:\n"
        for key, value in preferences.items():
            prompt += f"{key}: {value}\n"
        prompt += "\nDestinations:\n"
        for destination in self.destinations:
            prompt += f"- {destination['name']}: {destination['description']}\n"
        return prompt

# Example usage
destinations = [
    {"name": "Paris", "description": "City of lights, known for its art, fashion, and culture."},
    {"name": "Tokyo", "description": "Vibrant city, famous for its modernity and traditional temples."},
    {"name": "New York", "description": "The city that never sleeps, with iconic landmarks and diverse culture."},
    {"name": "Sydney", "description": "Beautiful harbour city, known for its opera house and stunning beaches."},
]

preferences = {"activity": "sightseeing", "culture": "diverse"}
api_key = 'your_azure_openai_api_key'
endpoint = 'https://your-endpoint.com/openai/deployments/your-deployment-name/completions?api-version=2022-12-01'

travel_agent = TravelAgent(destinations)
recommendations = travel_agent.get_recommendations(preferences, api_key, endpoint)
print("Recommended Destinations:")
for rec in recommendations:
    print(rec)
```

#### कोड व्याख्या - Preference Booker

1. **इनिशियलाइज़ेशन**: `TravelAgent` क्लास संभावित यात्रा गंतव्यों की एक सूची के साथ इनिशियलाइज़ होती है, जिनमें नाम और विवरण जैसे गुण होते हैं।

2. **सिफारिशें प्राप्त करना (`get_recommendations` मेथड)**: यह मेथड उपयोगकर्ता की पसंद के आधार पर Azure OpenAI सेवा के लिए एक प्रॉम्प्ट बनाता है और Azure OpenAI API को HTTP POST अनुरोध भेजता है ताकि पुनः रैंक और स्कोर किए गए गंतव्य प्राप्त किए जा सकें।

3. **प्रॉम्प्ट जनरेट करना (`generate_prompt` मेथड)**: यह मेथड Azure OpenAI के लिए एक प्रॉम्प्ट बनाता है, जिसमें उपयोगकर्ता की पसंद और गंतव्यों की सूची शामिल होती है। प्रॉम्प्ट मॉडल को गंतव्यों को पुनः रैंक और स्कोर करने के लिए निर्देशित करता है।

4. **API कॉल**: `requests` लाइब्रेरी का उपयोग Azure OpenAI API एंडपॉइंट पर HTTP POST अनुरोध भेजने के लिए किया जाता है। प्रतिक्रिया में पुनः रैंक और स्कोर किए गए गंतव्य होते हैं।

5. **उदाहरण उपयोग**: ट्रैवल एजेंट उपयोगकर्ता की पसंद (जैसे सैर-सपाटा और विविध संस्कृति में रुचि) एकत्र करता है और Azure OpenAI सेवा का उपयोग करके पुनः रैंक और स्कोर की गई सिफारिशें प्राप्त करता है।

ध्यान दें कि `your_azure_openai_api_key` को अपनी वास्तविक Azure OpenAI API कुंजी से और `https://your-endpoint.com/...` को अपने Azure OpenAI डिप्लॉयमेंट के वास्तविक एंडपॉइंट URL से बदलें।

LLM का पुनः रैंकिंग और स्कोरिंग के लिए उपयोग करके, ट्रैवल एजेंट ग्राहकों को अधिक व्यक्तिगत और प्रासंगिक यात्रा सिफारिशें प्रदान कर सकता है, जिससे उनका अनुभव बेहतर होता है।

### RAG: प्रॉम्प्टिंग तकनीक बनाम टूल

Retrieval-Augmented Generation (RAG) AI एजेंट विकास में एक प्रॉम्प्टिंग तकनीक और एक टूल दोनों हो सकता है। दोनों के बीच अंतर समझना आपको RAG का अधिक प्रभावी उपयोग करने में मदद करेगा।

#### प्रॉम्प्टिंग तकनीक के रूप में RAG

**यह क्या है?**

- प्रॉम्प्टिंग तकनीक के रूप में, RAG विशिष्ट क्वेरी या प्रॉम्प्ट बनाकर बड़े डेटाबेस या कॉर्पस से प्रासंगिक जानकारी प्राप्त करने में मदद करता है। फिर इस जानकारी का उपयोग उत्तर या क्रियाएं उत्पन्न करने के लिए किया जाता है।

**यह कैसे काम करता है:**

1. **प्रॉम्प्ट बनाना**: कार्य या उपयोगकर्ता इनपुट के आधार पर अच्छी तरह से संरचित प्रॉम्प्ट या क्वेरी बनाएं।
2. **जानकारी प्राप्त करना**: प्रॉम्प्ट का उपयोग करके पूर्व-निर्मित ज्ञान आधार या डेटासेट से प्रासंगिक डेटा खोजें।
3. **उत्तर उत्पन्न करना**: प्राप्त जानकारी को जनरेटिव AI मॉडल के साथ मिलाकर एक समग्र और सुसंगत उत्तर बनाएं।

**ट्रैवल एजेंट में उदाहरण**:

- उपयोगकर्ता इनपुट: "मैं पेरिस के संग्रहालयों में जाना चाहता हूँ।"
- प्रॉम्प्ट: "पेरिस के शीर्ष संग्रहालय खोजें।"
- प्राप्त जानकारी: लूव्र संग्रहालय, म्यूज़े ड'ऑर्से आदि के विवरण।
- उत्पन्न उत्तर: "पेरिस के कुछ प्रमुख संग्रहालय हैं: लूव्र संग्रहालय, म्यूज़े ड'ऑर्से, और सेंट्रे पोंपिडू।"

#### टूल के रूप में RAG

**यह क्या है?**

- टूल के रूप में, RAG एक एकीकृत सिस्टम है जो पुनः प्राप्ति और जनरेशन प्रक्रिया को स्वचालित करता है, जिससे डेवलपर्स को प्रत्येक क्वेरी के लिए मैन्युअल प्रॉम्प्ट बनाने की जरूरत नहीं होती।

**यह कैसे काम करता है:**

1. **एकीकरण**: RAG को AI एजेंट की संरचना में एम्बेड करें, जिससे यह स्वचालित रूप से पुनः प्राप्ति और जनरेशन कार्य संभाले।
2. **स्वचालन**: टूल पूरी प्रक्रिया को प्रबंधित करता है, उपयोगकर्ता इनपुट से लेकर अंतिम उत्तर उत्पन्न करने तक, बिना हर चरण के लिए स्पष्ट प्रॉम्प्ट की आवश्यकता के।
3. **कुशलता**: पुनः प्राप्ति और जनरेशन प्रक्रिया को सरल बनाकर एजेंट के प्रदर्शन को बेहतर बनाता है, जिससे तेज़ और अधिक सटीक उत्तर मिलते हैं।

**ट्रैवल एजेंट में उदाहरण**:

- उपयोगकर्ता इनपुट: "मैं पेरिस के संग्रहालयों में जाना चाहता हूँ।"
- RAG टूल: स्वचालित रूप से संग्रहालयों की जानकारी प्राप्त करता है और उत्तर उत्पन्न करता है।
- उत्पन्न उत्तर: "पेरिस के कुछ प्रमुख संग्रहालय हैं: लूव्र संग्रहालय, म्यूज़े ड'ऑर्से, और सेंट्रे पोंपिडू।"

### तुलना

| पहलू                  | प्रॉम्प्टिंग तकनीक                                         | टूल                                                  |
|------------------------|------------------------------------------------------------|-------------------------------------------------------|
| **मैन्युअल बनाम स्वचालित** | प्रत्येक क्वेरी के लिए मैन्युअल प्रॉम्प्ट बनाना।               | पुनः प्राप्ति और जनरेशन के लिए स्वचालित प्रक्रिया।       |
| **नियंत्रण**            | पुनः प्राप्ति प्रक्रिया पर अधिक नियंत्रण प्रदान करता है।       | पुनः प्राप्ति और जनरेशन को सरल और स्वचालित बनाता है।     |
| **लचीलापन**            | विशिष्ट आवश्यकताओं के अनुसार कस्टम प्रॉम्प्ट बनाने की अनुमति।    | बड़े पैमाने पर कार्यान्वयन के लिए अधिक कुशल।             |
| **जटिलता**             | प्रॉम्प्ट बनाने और समायोजित करने की आवश्यकता होती है।          | AI एजेंट की संरचना में आसानी से एकीकृत किया जा सकता है।  |

### व्यावहारिक उदाहरण

**प्रॉम्प्टिंग तकनीक का उदाहरण:**

```python
def search_museums_in_paris():
    prompt = "Find top museums in Paris"
    search_results = search_web(prompt)
    return search_results

museums = search_museums_in_paris()
print("Top Museums in Paris:", museums)
```

**टूल का उदाहरण:**

```python
class Travel_Agent:
    def __init__(self):
        self.rag_tool = RAGTool()

    def get_museums_in_paris(self):
        user_input = "I want to visit museums in Paris."
        response = self.rag_tool.retrieve_and_generate(user_input)
        return response

travel_agent = Travel_Agent()
museums = travel_agent.get_museums_in_paris()
print("Top Museums in Paris:", museums)
```

### प्रासंगिकता का मूल्यांकन

प्रासंगिकता का मूल्यांकन AI एजेंट के प्रदर्शन का एक महत्वपूर्ण पहलू है। यह सुनिश्चित करता है कि एजेंट द्वारा प्राप्त और उत्पन्न जानकारी उपयुक्त, सटीक और उपयोगी हो। आइए देखें कि AI एजेंट में प्रासंगिकता का मूल्यांकन कैसे किया जाता है, साथ ही व्यावहारिक उदाहरण और तकनीकें।

#### प्रासंगिकता मूल्यांकन के मुख्य सिद्धांत

1. **संदर्भ जागरूकता**:
   - एजेंट को उपयोगकर्ता की क्वेरी के संदर्भ को समझना चाहिए ताकि वह प्रासंगिक जानकारी प्राप्त और उत्पन्न कर सके।
   - उदाहरण: यदि उपयोगकर्ता "पेरिस के सर्वश्रेष्ठ रेस्तरां" पूछता है, तो एजेंट को उपयोगकर्ता की पसंद जैसे भोजन प्रकार और बजट को ध्यान में रखना चाहिए।

2. **सटीकता**:
   - एजेंट द्वारा दी गई जानकारी तथ्यात्मक रूप से सही और अद्यतित होनी चाहिए।
   - उदाहरण: वर्तमान में खुले और अच्छी समीक्षाओं वाले रेस्तरां सुझाना, न कि पुराने या बंद हो चुके विकल्प।

3. **उपयोगकर्ता की मंशा**:
   - एजेंट को क्वेरी के पीछे उपयोगकर्ता की मंशा का अनुमान लगाना चाहिए ताकि सबसे प्रासंगिक जानकारी प्रदान की जा सके।
   - उदाहरण: यदि उपयोगकर्ता "बजट-फ्रेंडली होटल" पूछता है, तो एजेंट को किफायती विकल्प प्राथमिकता देनी चाहिए।

4. **प्रतिक्रिया चक्र**:
   - उपयोगकर्ता की प्रतिक्रिया लगातार एकत्रित और विश्लेषित करके एजेंट अपनी प्रासंगिकता मूल्यांकन प्रक्रिया को बेहतर बनाता है।
   - उदाहरण: पिछले सुझावों पर उपयोगकर्ता की रेटिंग और प्रतिक्रिया को शामिल करना ताकि भविष्य के उत्तर बेहतर हों।

#### प्रासंगिकता मूल्यांकन के व्यावहारिक तरीके

1. **प्रासंगिकता स्कोरिंग**:
   - प्रत्येक प्राप्त आइटम को उपयोगकर्ता की क्वेरी और पसंद के अनुसार प्रासंगिकता स्कोर दें।
   - उदाहरण:

     ```python
     def relevance_score(item, query):
         score = 0
         if item['category'] in query['interests']:
             score += 1
         if item['price'] <= query['budget']:
             score += 1
         if item['location'] == query['destination']:
             score += 1
         return score
     ```

2. **फ़िल्टरिंग और रैंकिंग**:
   - अप्रासंगिक आइटम हटाएं और शेष को उनके प्रासंगिकता स्कोर के आधार पर रैंक करें।
   - उदाहरण:

     ```python
     def filter_and_rank(items, query):
         ranked_items = sorted(items, key=lambda item: relevance_score(item, query), reverse=True)
         return ranked_items[:10]  # Return top 10 relevant items
     ```

3. **प्राकृतिक भाषा प्रसंस्करण (NLP)**:
   - उपयोगकर्ता की क्वेरी को समझने और प्रासंगिक जानकारी प्राप्त करने के लिए NLP तकनीकों का उपयोग करें।
   - उदाहरण:

     ```python
     def process_query(query):
         # Use NLP to extract key information from the user's query
         processed_query = nlp(query)
         return processed_query
     ```

4. **उपयोगकर्ता प्रतिक्रिया एकीकरण**:
   - प्रदान की गई सिफारिशों पर उपयोगकर्ता की प्रतिक्रिया एकत्र करें और भविष्य के प्रासंगिकता मूल्यांकन को समायोजित करें।
   - उदाहरण:

     ```python
     def adjust_based_on_feedback(feedback, items):
         for item in items:
             if item['name'] in feedback['liked']:
                 item['relevance'] += 1
             if item['name'] in feedback['disliked']:
                 item['relevance'] -= 1
         return items
     ```

#### उदाहरण: ट्रैवल एजेंट में प्रासंगिकता का मूल्यांकन

यहाँ एक व्यावहारिक उदाहरण है कि ट्रैवल एजेंट यात्रा सिफारिशों की प्रासंगिकता कैसे मूल्यांकन कर सकता है:

```python
class Travel_Agent:
    def __init__(self):
        self.user_preferences = {}
        self.experience_data = []

    def gather_preferences(self, preferences):
        self.user_preferences = preferences

    def retrieve_information(self):
        flights = search_flights(self.user_preferences)
        hotels = search_hotels(self.user_preferences)
        attractions = search_attractions(self.user_preferences)
        return flights, hotels, attractions

    def generate_recommendations(self):
        flights, hotels, attractions = self.retrieve_information()
        ranked_hotels = self.filter_and_rank(hotels, self.user_preferences)
        itinerary = create_itinerary(flights, ranked_hotels, attractions)
        return itinerary

    def filter_and_rank(self, items, query):
        ranked_items = sorted(items, key=lambda item: self.relevance_score(item, query), reverse=True)
        return ranked_items[:10]  # Return top 10 relevant items

    def relevance_score(self, item, query):
        score = 0
        if item['category'] in query['interests']:
            score += 1
        if item['price'] <= query['budget']:
            score += 1
        if item['location'] == query['destination']:
            score += 1
        return score

    def adjust_based_on_feedback(self, feedback, items):
        for item in items:
            if item['name'] in feedback['liked']:
                item['relevance'] += 1
            if item['name'] in feedback['disliked']:
                item['relevance'] -= 1
        return items

# Example usage
travel_agent = Travel_Agent()
preferences = {
    "destination": "Paris",
    "dates": "2025-04-01 to 2025-04-10",
    "budget": "moderate",
    "interests": ["museums", "cuisine"]
}
travel_agent.gather_preferences(preferences)
itinerary = travel_agent.generate_recommendations()
print("Suggested Itinerary:", itinerary)
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_items = travel_agent.adjust_based_on_feedback(feedback, itinerary['hotels'])
print("Updated Itinerary with Feedback:", updated_items)
```

### मंशा के साथ खोज

मंशा के साथ खोज का मतलब है उपयोगकर्ता की क्वेरी के पीछे छिपे उद्देश्य या लक्ष्य को समझना और व्याख्यायित करना ताकि सबसे प्रासंगिक और उपयोगी जानकारी प्राप्त और उत्पन्न की जा सके। यह तरीका केवल कीवर्ड मिलान से आगे बढ़कर उपयोगकर्ता की वास्तविक जरूरतों और संदर्भ को पकड़ने पर केंद्रित होता है।

#### मंशा के साथ खोज के मुख्य सिद्धांत

1. **उपयोगकर्ता की मंशा को समझना**:
   - उपयोगकर्ता की मंशा मुख्य रूप से तीन प्रकार की हो सकती है: सूचना संबंधी, नेविगेशनल, और लेन-देन संबंधी।
     - **सूचना संबंधी मंशा**: उपयोगकर्ता किसी विषय के बारे में जानकारी चाहता है (जैसे, "पेरिस के सर्वश्रेष्ठ संग्रहालय कौन से हैं?")।
     - **नेविगेशनल मंशा**: उपयोगकर्ता किसी विशिष्ट वेबसाइट या पेज पर जाना चाहता है (जैसे, "लूव्र संग्रहालय की आधिकारिक वेबसाइट")।
     - **लेन-देन संबंधी मंशा**: उपयोगकर्ता कोई लेन-देन करना चाहता है, जैसे फ्लाइट बुक करना या खरीदारी करना (जैसे, "पेरिस के लिए फ्लाइट बुक करें")।

2. **संदर्भ जागरूकता**:
   - उपयोगकर्ता की क्वेरी के संदर्भ का विश्लेषण करना, जिसमें पिछली बातचीत, उपयोगकर्ता की पसंद, और वर्तमान क्वेरी के विशिष्ट विवरण शामिल हैं, ताकि उनकी मंशा सही से पहचानी जा सके।

3. **प्राकृतिक भाषा प्रसंस्करण (NLP)**:
   - उपयोगकर्ताओं द्वारा दी गई प्राकृतिक भाषा क्वेरी को समझने और व्याख्यायित करने के लिए NLP तकनीकों का उपयोग किया जाता है। इसमें एंटिटी रिकग्निशन, सेंटिमेंट एनालिसिस, और क्वेरी पार्सिंग शामिल हैं।

4. **व्यक्तिगतकरण**:
   - उपयोगकर्ता के इतिहास, पसंद, और प्रतिक्रिया के आधार पर खोज परिणामों को व्यक्तिगत बनाना, जिससे प्राप्त जानकारी की प्रासंगिकता बढ़ती है।
#### व्यावहारिक उदाहरण: ट्रैवल एजेंट में इरादे के साथ खोज

आइए ट्रैवल एजेंट को उदाहरण के रूप में लें और देखें कि इरादे के साथ खोज कैसे लागू की जा सकती है।

1. **उपयोगकर्ता की प्राथमिकताएँ एकत्रित करना**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **उपयोगकर्ता के इरादे को समझना**

   ```python
   def identify_intent(query):
       if "book" in query or "purchase" in query:
           return "transactional"
       elif "website" in query or "official" in query:
           return "navigational"
       else:
           return "informational"
   ```

3. **संदर्भ जागरूकता**

   ```python
   def analyze_context(query, user_history):
       # Combine current query with user history to understand context
       context = {
           "current_query": query,
           "user_history": user_history
       }
       return context
   ```

4. **खोज और परिणामों को व्यक्तिगत बनाना**

   ```python
   def search_with_intent(query, preferences, user_history):
       intent = identify_intent(query)
       context = analyze_context(query, user_history)
       if intent == "informational":
           search_results = search_information(query, preferences)
       elif intent == "navigational":
           search_results = search_navigation(query)
       elif intent == "transactional":
           search_results = search_transaction(query, preferences)
       personalized_results = personalize_results(search_results, user_history)
       return personalized_results

   def search_information(query, preferences):
       # Example search logic for informational intent
       results = search_web(f"best {preferences['interests']} in {preferences['destination']}")
       return results

   def search_navigation(query):
       # Example search logic for navigational intent
       results = search_web(query)
       return results

   def search_transaction(query, preferences):
       # Example search logic for transactional intent
       results = search_web(f"book {query} to {preferences['destination']}")
       return results

   def personalize_results(results, user_history):
       # Example personalization logic
       personalized = [result for result in results if result not in user_history]
       return personalized[:10]  # Return top 10 personalized results
   ```

5. **उदाहरण उपयोग**

   ```python
   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   user_history = ["Louvre Museum website", "Book flight to Paris"]
   query = "best museums in Paris"
   results = search_with_intent(query, preferences, user_history)
   print("Search Results:", results)
   ```

---

## 4. टूल के रूप में कोड जनरेट करना

कोड जनरेट करने वाले एजेंट AI मॉडल का उपयोग कोड लिखने और चलाने के लिए करते हैं, जिससे जटिल समस्याओं का समाधान होता है और कार्य स्वचालित होते हैं।

### कोड जनरेट करने वाले एजेंट

कोड जनरेट करने वाले एजेंट जनरेटिव AI मॉडल का उपयोग कोड लिखने और चलाने के लिए करते हैं। ये एजेंट जटिल समस्याओं को हल कर सकते हैं, कार्यों को स्वचालित कर सकते हैं, और विभिन्न प्रोग्रामिंग भाषाओं में कोड जनरेट और रन करके मूल्यवान जानकारी प्रदान कर सकते हैं।

#### व्यावहारिक अनुप्रयोग

1. **स्वचालित कोड जनरेशन**: विशिष्ट कार्यों के लिए कोड स्निपेट्स जनरेट करना, जैसे डेटा विश्लेषण, वेब स्क्रैपिंग, या मशीन लर्निंग।
2. **SQL को RAG के रूप में उपयोग करना**: डेटाबेस से डेटा प्राप्त करने और उसे संशोधित करने के लिए SQL क्वेरी का उपयोग।
3. **समस्या समाधान**: विशिष्ट समस्याओं को हल करने के लिए कोड बनाना और चलाना, जैसे एल्गोरिदम का अनुकूलन या डेटा विश्लेषण।

#### उदाहरण: डेटा विश्लेषण के लिए कोड जनरेटिंग एजेंट

कल्पना करें कि आप एक कोड जनरेटिंग एजेंट डिजाइन कर रहे हैं। यह इस तरह काम कर सकता है:

1. **कार्य**: डेटा सेट का विश्लेषण कर रुझान और पैटर्न पहचानना।
2. **कदम**:
   - डेटा सेट को डेटा विश्लेषण उपकरण में लोड करना।
   - डेटा को फ़िल्टर और समेकित करने के लिए SQL क्वेरी जनरेट करना।
   - क्वेरी चलाना और परिणाम प्राप्त करना।
   - परिणामों का उपयोग करके विज़ुअलाइज़ेशन और अंतर्दृष्टि बनाना।
3. **आवश्यक संसाधन**: डेटा सेट तक पहुंच, डेटा विश्लेषण उपकरण, और SQL क्षमताएं।
4. **अनुभव**: पिछले विश्लेषण परिणामों का उपयोग भविष्य के विश्लेषण की सटीकता और प्रासंगिकता बढ़ाने के लिए करना।

### उदाहरण: ट्रैवल एजेंट के लिए कोड जनरेटिंग एजेंट

इस उदाहरण में, हम एक कोड जनरेटिंग एजेंट, ट्रैवल एजेंट, डिजाइन करेंगे जो उपयोगकर्ताओं को यात्रा की योजना बनाने में मदद करेगा, कोड जनरेट और निष्पादित करके। यह एजेंट यात्रा विकल्प प्राप्त करने, परिणामों को फ़िल्टर करने, और जनरेटिव AI का उपयोग करके यात्रा कार्यक्रम तैयार करने जैसे कार्य कर सकता है।

#### कोड जनरेटिंग एजेंट का अवलोकन

1. **उपयोगकर्ता की प्राथमिकताएँ एकत्रित करना**: गंतव्य, यात्रा तिथियाँ, बजट, और रुचियों जैसी जानकारी इकट्ठा करता है।
2. **डेटा प्राप्त करने के लिए कोड जनरेट करना**: उड़ान, होटल, और आकर्षण के बारे में डेटा प्राप्त करने के लिए कोड स्निपेट्स बनाता है।
3. **जनरेट किए गए कोड को चलाना**: वास्तविक समय की जानकारी प्राप्त करने के लिए कोड चलाता है।
4. **यात्रा कार्यक्रम बनाना**: प्राप्त डेटा को व्यक्तिगत यात्रा योजना में संकलित करता है।
5. **प्रतिक्रिया के आधार पर समायोजन**: उपयोगकर्ता की प्रतिक्रिया प्राप्त करता है और आवश्यक होने पर परिणामों को बेहतर बनाने के लिए कोड पुनः जनरेट करता है।

#### चरण-दर-चरण कार्यान्वयन

1. **उपयोगकर्ता की प्राथमिकताएँ एकत्रित करना**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **डेटा प्राप्त करने के लिए कोड जनरेट करना**

   ```python
   def generate_code_to_fetch_data(preferences):
       # Example: Generate code to search for flights based on user preferences
       code = f"""
       def search_flights():
           import requests
           response = requests.get('https://api.example.com/flights', params={preferences})
           return response.json()
       """
       return code

   def generate_code_to_fetch_hotels(preferences):
       # Example: Generate code to search for hotels
       code = f"""
       def search_hotels():
           import requests
           response = requests.get('https://api.example.com/hotels', params={preferences})
           return response.json()
       """
       return code
   ```

3. **जनरेट किए गए कोड को चलाना**

   ```python
   def execute_code(code):
       # Execute the generated code using exec
       exec(code)
       result = locals()
       return result

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   
   flight_code = generate_code_to_fetch_data(preferences)
   hotel_code = generate_code_to_fetch_hotels(preferences)
   
   flights = execute_code(flight_code)
   hotels = execute_code(hotel_code)

   print("Flight Options:", flights)
   print("Hotel Options:", hotels)
   ```

4. **यात्रा कार्यक्रम बनाना**

   ```python
   def generate_itinerary(flights, hotels, attractions):
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   attractions = search_attractions(preferences)
   itinerary = generate_itinerary(flights, hotels, attractions)
   print("Suggested Itinerary:", itinerary)
   ```

5. **प्रतिक्रिया के आधार पर समायोजन**

   ```python
   def adjust_based_on_feedback(feedback, preferences):
       # Adjust preferences based on user feedback
       if "liked" in feedback:
           preferences["favorites"] = feedback["liked"]
       if "disliked" in feedback:
           preferences["avoid"] = feedback["disliked"]
       return preferences

   feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
   updated_preferences = adjust_based_on_feedback(feedback, preferences)
   
   # Regenerate and execute code with updated preferences
   updated_flight_code = generate_code_to_fetch_data(updated_preferences)
   updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)
   
   updated_flights = execute_code(updated_flight_code)
   updated_hotels = execute_code(updated_hotel_code)
   
   updated_itinerary = generate_itinerary(updated_flights, updated_hotels, attractions)
   print("Updated Itinerary:", updated_itinerary)
   ```

### पर्यावरण जागरूकता और तर्क का लाभ उठाना

टेबल के स्कीमा के आधार पर क्वेरी जनरेशन प्रक्रिया को पर्यावरण जागरूकता और तर्क का उपयोग करके बेहतर बनाया जा सकता है।

यहाँ बताया गया है कि इसे कैसे किया जा सकता है:

1. **स्कीमा को समझना**: सिस्टम टेबल के स्कीमा को समझेगा और इस जानकारी का उपयोग क्वेरी जनरेशन को आधार देने के लिए करेगा।
2. **प्रतिक्रिया के आधार पर समायोजन**: सिस्टम उपयोगकर्ता की प्राथमिकताओं को प्रतिक्रिया के आधार पर समायोजित करेगा और यह तर्क करेगा कि स्कीमा के किन फील्ड्स को अपडेट करने की जरूरत है।
3. **क्वेरी जनरेट और निष्पादित करना**: सिस्टम नई प्राथमिकताओं के आधार पर अपडेटेड उड़ान और होटल डेटा प्राप्त करने के लिए क्वेरी जनरेट और निष्पादित करेगा।

यहाँ एक अपडेटेड Python कोड उदाहरण है जो इन अवधारणाओं को शामिल करता है:

```python
def adjust_based_on_feedback(feedback, preferences, schema):
    # Adjust preferences based on user feedback
    if "liked" in feedback:
        preferences["favorites"] = feedback["liked"]
    if "disliked" in feedback:
        preferences["avoid"] = feedback["disliked"]
    # Reasoning based on schema to adjust other related preferences
    for field in schema:
        if field in preferences:
            preferences[field] = adjust_based_on_environment(feedback, field, schema)
    return preferences

def adjust_based_on_environment(feedback, field, schema):
    # Custom logic to adjust preferences based on schema and feedback
    if field in feedback["liked"]:
        return schema[field]["positive_adjustment"]
    elif field in feedback["disliked"]:
        return schema[field]["negative_adjustment"]
    return schema[field]["default"]

def generate_code_to_fetch_data(preferences):
    # Generate code to fetch flight data based on updated preferences
    return f"fetch_flights(preferences={preferences})"

def generate_code_to_fetch_hotels(preferences):
    # Generate code to fetch hotel data based on updated preferences
    return f"fetch_hotels(preferences={preferences})"

def execute_code(code):
    # Simulate execution of code and return mock data
    return {"data": f"Executed: {code}"}

def generate_itinerary(flights, hotels, attractions):
    # Generate itinerary based on flights, hotels, and attractions
    return {"flights": flights, "hotels": hotels, "attractions": attractions}

# Example schema
schema = {
    "favorites": {"positive_adjustment": "increase", "negative_adjustment": "decrease", "default": "neutral"},
    "avoid": {"positive_adjustment": "decrease", "negative_adjustment": "increase", "default": "neutral"}
}

# Example usage
preferences = {"favorites": "sightseeing", "avoid": "crowded places"}
feedback = {"liked": ["Louvre Museum"], "disliked": ["Eiffel Tower (too crowded)"]}
updated_preferences = adjust_based_on_feedback(feedback, preferences, schema)

# Regenerate and execute code with updated preferences
updated_flight_code = generate_code_to_fetch_data(updated_preferences)
updated_hotel_code = generate_code_to_fetch_hotels(updated_preferences)

updated_flights = execute_code(updated_flight_code)
updated_hotels = execute_code(updated_hotel_code)

updated_itinerary = generate_itinerary(updated_flights, updated_hotels, feedback["liked"])
print("Updated Itinerary:", updated_itinerary)
```

#### व्याख्या - प्रतिक्रिया के आधार पर बुकिंग

1. **स्कीमा जागरूकता**: `schema` डिक्शनरी यह परिभाषित करती है कि प्रतिक्रिया के आधार पर प्राथमिकताओं को कैसे समायोजित किया जाना चाहिए। इसमें `favorites` और `avoid` जैसे फील्ड्स शामिल हैं, जिनके लिए समायोजन निर्दिष्ट हैं।
2. **प्राथमिकताओं को समायोजित करना (`adjust_based_on_feedback` मेथड)**: यह मेथड उपयोगकर्ता की प्रतिक्रिया और स्कीमा के आधार पर प्राथमिकताओं को समायोजित करता है।
3. **पर्यावरण आधारित समायोजन (`adjust_based_on_environment` मेथड)**: यह मेथड स्कीमा और प्रतिक्रिया के आधार पर समायोजन को अनुकूलित करता है।
4. **क्वेरी जनरेट और निष्पादित करना**: सिस्टम समायोजित प्राथमिकताओं के आधार पर अपडेटेड उड़ान और होटल डेटा प्राप्त करने के लिए कोड जनरेट करता है और इन क्वेरियों के निष्पादन का अनुकरण करता है।
5. **यात्रा कार्यक्रम बनाना**: सिस्टम नए उड़ान, होटल, और आकर्षण डेटा के आधार पर अपडेटेड यात्रा कार्यक्रम बनाता है।

सिस्टम को पर्यावरण-जागरूक और स्कीमा आधारित तर्कशील बनाकर, यह अधिक सटीक और प्रासंगिक क्वेरियां जनरेट कर सकता है, जिससे बेहतर यात्रा सिफारिशें और अधिक व्यक्तिगत उपयोगकर्ता अनुभव संभव होता है।

### SQL का उपयोग Retrieval-Augmented Generation (RAG) तकनीक के रूप में

SQL (Structured Query Language) डेटाबेस के साथ इंटरैक्ट करने के लिए एक शक्तिशाली उपकरण है। जब इसे Retrieval-Augmented Generation (RAG) दृष्टिकोण के हिस्से के रूप में उपयोग किया जाता है, तो SQL डेटाबेस से प्रासंगिक डेटा प्राप्त कर AI एजेंटों में प्रतिक्रियाएं या क्रियाएं उत्पन्न करने में मदद करता है। आइए देखें कि ट्रैवल एजेंट के संदर्भ में SQL को RAG तकनीक के रूप में कैसे इस्तेमाल किया जा सकता है।

#### मुख्य अवधारणाएँ

1. **डेटाबेस इंटरैक्शन**:
   - SQL का उपयोग डेटाबेस से जानकारी प्राप्त करने और डेटा को संशोधित करने के लिए किया जाता है।
   - उदाहरण: ट्रैवल डेटाबेस से उड़ान विवरण, होटल जानकारी, और आकर्षण प्राप्त करना।

2. **RAG के साथ एकीकरण**:
   - SQL क्वेरियां उपयोगकर्ता इनपुट और प्राथमिकताओं के आधार पर जनरेट की जाती हैं।
   - प्राप्त डेटा का उपयोग व्यक्तिगत सिफारिशें या क्रियाएं उत्पन्न करने के लिए किया जाता है।

3. **डायनामिक क्वेरी जनरेशन**:
   - AI एजेंट संदर्भ और उपयोगकर्ता की जरूरतों के अनुसार डायनामिक SQL क्वेरियां बनाता है।
   - उदाहरण: बजट, तिथियों, और रुचियों के आधार पर परिणामों को फ़िल्टर करने के लिए SQL क्वेरियां अनुकूलित करना।

#### अनुप्रयोग

- **स्वचालित कोड जनरेशन**: विशिष्ट कार्यों के लिए कोड स्निपेट्स बनाना।
- **SQL को RAG के रूप में उपयोग करना**: डेटा को संशोधित करने के लिए SQL क्वेरियों का उपयोग।
- **समस्या समाधान**: समस्याओं को हल करने के लिए कोड बनाना और चलाना।

**उदाहरण**:  
एक डेटा विश्लेषण एजेंट:

1. **कार्य**: रुझान खोजने के लिए डेटा सेट का विश्लेषण करना।  
2. **कदम**:  
   - डेटा सेट लोड करना।  
   - डेटा को फ़िल्टर करने के लिए SQL क्वेरियां बनाना।  
   - क्वेरियां चलाना और परिणाम प्राप्त करना।  
   - विज़ुअलाइज़ेशन और अंतर्दृष्टि बनाना।  
3. **संसाधन**: डेटा सेट तक पहुंच, SQL क्षमताएं।  
4. **अनुभव**: भविष्य के विश्लेषण को बेहतर बनाने के लिए पिछले परिणामों का उपयोग।

#### व्यावहारिक उदाहरण: ट्रैवल एजेंट में SQL का उपयोग

1. **उपयोगकर्ता की प्राथमिकताएँ एकत्रित करना**

   ```python
   class Travel_Agent:
       def __init__(self):
           self.user_preferences = {}

       def gather_preferences(self, preferences):
           self.user_preferences = preferences
   ```

2. **SQL क्वेरियां जनरेट करना**

   ```python
   def generate_sql_query(table, preferences):
       query = f"SELECT * FROM {table} WHERE "
       conditions = []
       for key, value in preferences.items():
           conditions.append(f"{key}='{value}'")
       query += " AND ".join(conditions)
       return query
   ```

3. **SQL क्वेरियां निष्पादित करना**

   ```python
   import sqlite3

   def execute_sql_query(query, database="travel.db"):
       connection = sqlite3.connect(database)
       cursor = connection.cursor()
       cursor.execute(query)
       results = cursor.fetchall()
       connection.close()
       return results
   ```

4. **सिफारिशें जनरेट करना**

   ```python
   def generate_recommendations(preferences):
       flight_query = generate_sql_query("flights", preferences)
       hotel_query = generate_sql_query("hotels", preferences)
       attraction_query = generate_sql_query("attractions", preferences)
       
       flights = execute_sql_query(flight_query)
       hotels = execute_sql_query(hotel_query)
       attractions = execute_sql_query(attraction_query)
       
       itinerary = {
           "flights": flights,
           "hotels": hotels,
           "attractions": attractions
       }
       return itinerary

   travel_agent = Travel_Agent()
   preferences = {
       "destination": "Paris",
       "dates": "2025-04-01 to 2025-04-10",
       "budget": "moderate",
       "interests": ["museums", "cuisine"]
   }
   travel_agent.gather_preferences(preferences)
   itinerary = generate_recommendations(preferences)
   print("Suggested Itinerary:", itinerary)
   ```

#### SQL क्वेरियों के उदाहरण

1. **उड़ान क्वेरी**

   ```sql
   SELECT * FROM flights WHERE destination='Paris' AND dates='2025-04-01 to 2025-04-10' AND budget='moderate';
   ```

2. **होटल क्वेरी**

   ```sql
   SELECT * FROM hotels WHERE destination='Paris' AND budget='moderate';
   ```

3. **आकर्षण क्वेरी**

   ```sql
   SELECT * FROM attractions WHERE destination='Paris' AND interests='museums, cuisine';
   ```

Retrieval-Augmented Generation (RAG) तकनीक के हिस्से के रूप में SQL का उपयोग करके, ट्रैवल एजेंट जैसे AI एजेंट प्रासंगिक डेटा को डायनामिक रूप से प्राप्त और उपयोग कर सकते हैं, जिससे सटीक और व्यक्तिगत सिफारिशें प्रदान की जा सकें।

### मेटाकॉग्निशन का उदाहरण

तो मेटाकॉग्निशन के एक कार्यान्वयन को दिखाने के लिए, आइए एक सरल एजेंट बनाएं जो समस्या हल करते समय *अपने निर्णय लेने की प्रक्रिया पर विचार करता है*। इस उदाहरण में, हम एक ऐसा सिस्टम बनाएंगे जहाँ एजेंट होटल चुनने का प्रयास करता है, लेकिन फिर अपनी सोच का मूल्यांकन करता है और जब वह गलत या उपयुक्त नहीं होता, तो अपनी रणनीति समायोजित करता है।

हम इसे एक बुनियादी उदाहरण के रूप में सिमुलेट करेंगे जहाँ एजेंट कीमत और गुणवत्ता के संयोजन के आधार पर होटल चुनता है, लेकिन वह अपने निर्णयों पर "विचार" करता है और उसी के अनुसार समायोजन करता है।

#### यह मेटाकॉग्निशन को कैसे दर्शाता है:

1. **प्रारंभिक निर्णय**: एजेंट सबसे सस्ता होटल चुनेगा, बिना गुणवत्ता के प्रभाव को समझे।
2. **विचार और मूल्यांकन**: प्रारंभिक चयन के बाद, एजेंट उपयोगकर्ता की प्रतिक्रिया के आधार पर जांच करेगा कि क्या होटल "खराब" विकल्प था। यदि होटल की गुणवत्ता बहुत कम पाई जाती है, तो वह अपनी सोच पर विचार करेगा।
3. **रणनीति समायोजन**: एजेंट अपनी रणनीति को समायोजित करता है और "सबसे सस्ता" से "सबसे उच्च गुणवत्ता" पर स्विच करता है, जिससे भविष्य के निर्णय बेहतर होते हैं।

यहाँ एक उदाहरण है:

```python
class HotelRecommendationAgent:
    def __init__(self):
        self.previous_choices = []  # Stores the hotels chosen previously
        self.corrected_choices = []  # Stores the corrected choices
        self.recommendation_strategies = ['cheapest', 'highest_quality']  # Available strategies

    def recommend_hotel(self, hotels, strategy):
        """
        Recommend a hotel based on the chosen strategy.
        The strategy can either be 'cheapest' or 'highest_quality'.
        """
        if strategy == 'cheapest':
            recommended = min(hotels, key=lambda x: x['price'])
        elif strategy == 'highest_quality':
            recommended = max(hotels, key=lambda x: x['quality'])
        else:
            recommended = None
        self.previous_choices.append((strategy, recommended))
        return recommended

    def reflect_on_choice(self):
        """
        Reflect on the last choice made and decide if the agent should adjust its strategy.
        The agent considers if the previous choice led to a poor outcome.
        """
        if not self.previous_choices:
            return "No choices made yet."

        last_choice_strategy, last_choice = self.previous_choices[-1]
        # Let's assume we have some user feedback that tells us whether the last choice was good or not
        user_feedback = self.get_user_feedback(last_choice)

        if user_feedback == "bad":
            # Adjust strategy if the previous choice was unsatisfactory
            new_strategy = 'highest_quality' if last_choice_strategy == 'cheapest' else 'cheapest'
            self.corrected_choices.append((new_strategy, last_choice))
            return f"Reflecting on choice. Adjusting strategy to {new_strategy}."
        else:
            return "The choice was good. No need to adjust."

    def get_user_feedback(self, hotel):
        """
        Simulate user feedback based on hotel attributes.
        For simplicity, assume if the hotel is too cheap, the feedback is "bad".
        If the hotel has quality less than 7, feedback is "bad".
        """
        if hotel['price'] < 100 or hotel['quality'] < 7:
            return "bad"
        return "good"

# Simulate a list of hotels (price and quality)
hotels = [
    {'name': 'Budget Inn', 'price': 80, 'quality': 6},
    {'name': 'Comfort Suites', 'price': 120, 'quality': 8},
    {'name': 'Luxury Stay', 'price': 200, 'quality': 9}
]

# Create an agent
agent = HotelRecommendationAgent()

# Step 1: The agent recommends a hotel using the "cheapest" strategy
recommended_hotel = agent.recommend_hotel(hotels, 'cheapest')
print(f"Recommended hotel (cheapest): {recommended_hotel['name']}")

# Step 2: The agent reflects on the choice and adjusts strategy if necessary
reflection_result = agent.reflect_on_choice()
print(reflection_result)

# Step 3: The agent recommends again, this time using the adjusted strategy
adjusted_recommendation = agent.recommend_hotel(hotels, 'highest_quality')
print(f"Adjusted hotel recommendation (highest_quality): {adjusted_recommendation['name']}")
```

#### एजेंट की मेटाकॉग्निशन क्षमताएँ

यहाँ मुख्य बात है एजेंट की क्षमता:
- अपने पिछले निर्णयों और निर्णय लेने की प्रक्रिया का मूल्यांकन करना।
- उस विचार के आधार पर अपनी रणनीति समायोजित करना, यानी मेटाकॉग्निशन का क्रियान्वयन।

यह मेटाकॉग्निशन का एक सरल रूप है जहाँ सिस्टम आंतरिक प्रतिक्रिया के आधार पर अपनी सोच प्रक्रिया को समायोजित कर सकता है।

### निष्कर्ष

मेटाकॉग्निशन एक शक्तिशाली उपकरण है जो AI एजेंटों की क्षमताओं को काफी बढ़ा सकता है। मेटाकॉग्निटिव प्रक्रियाओं को शामिल करके, आप ऐसे एजेंट डिजाइन कर सकते हैं जो अधिक बुद्धिमान, अनुकूलनीय, और कुशल हों। अतिरिक्त संसाधनों का उपयोग करके AI एजेंटों में मेटाकॉग्निशन की रोचक दुनिया को और गहराई से जानें।

## पिछला पाठ

[Multi-Agent Design Pattern](../08-multi-agent/README.md)

## अगला पाठ

[AI Agents in Production](../10-ai-agents-production/README.md)

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता के लिए प्रयासरत हैं, कृपया ध्यान दें कि स्वचालित अनुवादों में त्रुटियाँ या अशुद्धियाँ हो सकती हैं। मूल दस्तावेज़ अपनी मूल भाषा में ही अधिकारिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सलाह दी जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।